了解しました。
以下は，第6回「数値解法とシミュレーション」の**講義動画（オンデマンド）用・読み上げ原稿**です。
各パート（Part 1, Part 2）はおよそ **1時間ずつ** の動画収録を想定し，
話し言葉として自然に聞こえるように整えています。
※スライドやJupyter実演と組み合わせて使えるように構成しています。

---

# 第6回講義：数値解法とシミュレーション

## Part 1　数値解法の原理とオイラー法

---

### 0. 導入（0:00〜5:00）

みなさん、こんにちは。
第6回は、「**数値解法とシミュレーション**」をテーマにお話しします。

これまでの講義では、解析的に解ける常微分方程式、たとえば指数関数的な増減やロジスティックモデル、あるいは単振り子の線形近似などを扱いました。
しかし、現実のモデルは必ずしも「解ける形」にはなっていません。
多くの非線形方程式や複雑なモデルは、紙と鉛筆だけでは解けません。

そこで登場するのが「**数値解法（numerical integration）**」です。
コンピュータの力で、微分方程式を時間ごとに少しずつ進めて、解の近似を求めていきます。
今日の講義では、解析的な解がない場合に、どのようにして時間発展を模倣するか、その基本的な考え方を学びます。

---

### 1. 微分から差分へ（5:00〜10:00）

微分方程式というのは、「傾き（変化の速さ）」が分かっている関係式です。
たとえば、
[
\frac{dx}{dt}=f(t,x)
]
という式は、「(t) と (x) が分かれば、次の瞬間の変化 (dx/dt) が分かる」という情報です。

これを、有限の刻み幅 (h) で近似すると、
[
\frac{dx}{dt}\approx\frac{x(t+h)-x(t)}{h}.
]
これを変形して、次の式を得ます。

[
x(t+h)=x(t)+h,f(t,x).
]

これが、**オイラー法（Euler method）**の原理です。
つまり、「現在の値 (x(t))」に、「そのときの傾き×刻み幅」を足して、次の時刻を予測する、という考え方です。

---

### 2. オイラー法を実装してみよう（10:00〜30:00）

では、具体的な例として、放射性崩壊のモデルを使ってみましょう。
微分方程式は
[
\frac{dN}{dt}=-\lambda N,\quad N(0)=N_0.
]
解析的な解は (N(t)=N_0 e^{-\lambda t}) ですが、今回はそれを**知らない前提**で数値的に進めてみます。

JupyterLabで次のコードを実行します。

```python
import numpy as np
import matplotlib.pyplot as plt
lam = 0.5
N0 = 10
dt = 0.2
t_max = 5
t = np.arange(0, t_max+dt, dt)
N = np.empty_like(t)
N[0] = N0

for k in range(len(t)-1):
    N[k+1] = N[k] - lam*N[k]*dt

N_exact = N0*np.exp(-lam*t)

plt.plot(t, N_exact, 'k--', label='解析解')
plt.plot(t, N, 'o-', label='オイラー法')
plt.xlabel('t'); plt.ylabel('N(t)')
plt.legend(); plt.grid(True, alpha=0.3)
plt.show()
```

プロットすると、解析解（黒の破線）とオイラー近似（青の点線）がほぼ重なります。
しかし、刻み幅 `dt` を大きくすると、どんどん精度が悪くなっていきます。

ここで重要なのは、「**小さい刻み幅ほど精度が上がるが、計算量も増える**」という点です。
これが、数値解析の基本的なトレードオフです。

---

### 3. 誤差と安定性（30:00〜45:00）

オイラー法の**誤差**を考えてみましょう。
1ステップあたりの誤差を「局所誤差」、全体として積み重なった誤差を「大域誤差」と呼びます。
オイラー法の局所誤差は (O(h^2))、大域誤差は (O(h)) です。
つまり、ステップ幅を半分にすると、全体の誤差はほぼ半分に減ります。

また、重要なのが**安定性**です。
たとえば、(\dot x = \lambda x) という単純な減衰方程式では、理論的には (x(t)) は 0 に収束しますが、
オイラー法で刻み幅 (h) を大きく取りすぎると、
[
x_{k+1} = (1+\lambda h)x_k
]
の係数が 1 を超えてしまい、数値解が**暴走**します。
このように、刻み幅の取り方には**安定条件**が存在します。
（この話は、後半の動画でさらに詳しく扱います。）

---

### 4. 改良オイラー法（Heun法）（45:00〜55:00）

オイラー法は単純ですが、誤差がやや大きい。
改良版のひとつに「**Heun法（改良オイラー法）**」があります。

これは、ステップの最初と最後の傾きを平均して進む方法です。

[
x_{k+1}=x_k+\frac{h}{2}\big(f(t_k,x_k)+f(t_{k+1},x_k+h f(t_k,x_k))\big)
]

これにより、局所誤差が (O(h^3)) に改善します。

---

### 5. まとめ（55:00〜60:00）

ここまでの要点です。

* オイラー法は「傾き×時間刻み」で進める最も単純な方法。
* 刻み幅を小さくすると精度は上がるが、計算コストが増える。
* 改良オイラー法は、2点の傾きを平均して精度を上げる。
* 安定性と精度の両立が重要。

次の動画（Part 2）では、より高精度な**ルンゲ＝クッタ法（RK法）**と、
実際の物理モデル（単振り子）への応用を扱います。

---

# 🎥 第6回講義：数値解法とシミュレーション

## Part 2　ルンゲ＝クッタ法と応用モデル

---

### 0. 導入（0:00〜5:00）

Part 2 では、オイラー法よりも高精度な方法、そして非線形モデルへの応用を扱います。
特に有名な「**4次のルンゲ＝クッタ法（RK4）**」を紹介し、単振り子の運動を数値的に再現します。

---

### 1. ルンゲ＝クッタ法（5:00〜25:00）

RK4法は、1ステップの間に4つの傾きを取って、その重み付き平均で進む方法です。

```python
def rk4(f, x0, t):
    x = np.empty_like(t)
    x[0] = x0
    h = t[1]-t[0]
    for k in range(len(t)-1):
        k1 = f(t[k], x[k])
        k2 = f(t[k]+h/2, x[k]+h*k1/2)
        k3 = f(t[k]+h/2, x[k]+h*k2/2)
        k4 = f(t[k]+h, x[k]+h*k3)
        x[k+1] = x[k] + (h/6)*(k1+2*k2+2*k3+k4)
    return x
```

指数的減衰の例で確認してみると、RK4法は非常に高精度で、解析解とほぼ一致します。
局所誤差は (O(h^5))、大域誤差は (O(h^4))。
この程度の精度があれば、多くの実用モデルで十分な精度が得られます。

---

### 2. 単振り子の数値解（25:00〜45:00）

次に、非線形の単振り子を数値的に解いてみましょう。

方程式は
[
\ddot\theta+\frac{g}{\ell}\sin\theta=0
]
です。

```python
g, ell = 9.8, 1.0
def pend_rhs(t, y):
    th, om = y
    return np.array([om, -(g/ell)*np.sin(th)])

def rk4_vec(f, y0, t):
    y = np.empty((len(t), len(y0)))
    y[0] = y0
    h = t[1]-t[0]
    for k in range(len(t)-1):
        k1 = f(t[k], y[k])
        k2 = f(t[k]+h/2, y[k]+h*k1/2)
        k3 = f(t[k]+h/2, y[k]+h*k2/2)
        k4 = f(t[k]+h, y[k]+h*k3)
        y[k+1] = y[k] + (h/6)*(k1+2*k2+2*k3+k4)
    return y
```

初期条件 (\theta(0)=30^\circ)，(\dot\theta(0)=0) として解きます。

```python
A = np.deg2rad(30)
t = np.linspace(0, 10, 2001)
y0 = np.array([A, 0.0])
sol = rk4_vec(pend_rhs, y0, t)
theta, omega = sol[:,0], sol[:,1]
```

結果をプロットすると、

* θ–t グラフでは、滑らかな周期運動が描かれます。
* 位相図（θ–ω平面）では、閉じた楕円状の軌道になります。

これは**エネルギーがほぼ保存されている**ことを意味します。

---

### 3. 安定性とエネルギー保存（45:00〜55:00）

オイラー法で同じ問題を解くと、時間とともに軌道が広がっていく、つまりエネルギーが増えていきます。
これはオイラー法が**非保存的**だからです。
対して、RK法やシンプレクティックオイラー法は、エネルギーを長期的にほぼ保存します。

**教訓**：
数値解法は「正確さ」だけでなく、「**物理的性質を壊さないか**」も重要です。

---

### 4. まとめと課題（55:00〜60:00）

ここまでの要点を整理します。

| 方法         | 精度 | 特徴            |
| ---------- | -- | ------------- |
| オイラー法      | 一次 | 単純だが誤差・不安定性あり |
| 改良オイラー     | 二次 | 簡単で精度向上       |
| ルンゲ＝クッタ4次法 | 四次 | 汎用・高精度        |
| シンプレクティック法 | 一次 | 長期安定・振動系向け    |

数値解法は、「**微分方程式の構造をどこまで忠実に模倣するか**」のアートでもあります。
モデルの性質に合わせて、方法と刻み幅を選ぶことが大切です。

---

### 課題案

1. ( \dot y=-2y ) をオイラー法・Heun法・RK4法で解き、刻み幅を変えて精度を比較する。
2. 単振り子をオイラー法とRK4法で比較し、位相図を重ねてエネルギーの違いを確認する。

---

### エンディング（最後の1分）

以上で第6回「数値解法とシミュレーション」を終わります。
次回は、これらの数値解を応用して、**モデルの解析・安定性・パラメータ推定**など、
より実践的な話題へ進んでいきます。

それでは、各自Jupyterでコードを実行し、結果を確認してください。
また次回の動画でお会いしましょう。

---

（※ここまでで約2時間分。Partごとに適宜休憩パートを挿入すると最適です。）
